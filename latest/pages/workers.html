<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Workers · DaskDistributedDispatcher.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/invenia.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DaskDistributedDispatcher.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><a class="toctext" href="manual.html">Manual</a></li><li><a class="toctext" href="api.html">API</a></li><li class="current"><a class="toctext" href="workers.html">Workers</a><ul class="internal"><li><a class="toctext" href="#Notable-Differences-1">Notable Differences</a></li><li><a class="toctext" href="#Tasks-1">Tasks</a></li><li><a class="toctext" href="#API-1">API</a></li><li><a class="toctext" href="#Internals-1">Internals</a></li></ul></li><li><a class="toctext" href="communication.html">Communication</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="workers.html">Workers</a></li></ul><a class="edit-page" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/docs/src/pages/workers.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Workers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Workers-1" href="#Workers-1">Workers</a></h1><p>Julia workers were developed that integrate with the python <a href="http://distributed.readthedocs.io/en/latest/setup.html"><code>dask-scheduler</code></a>, and hence follow many of the same patterns that the python <a href="http://distributed.readthedocs.io/en/latest/worker.html"><code>dask-workers</code></a> do.</p><h2><a class="nav-anchor" id="Notable-Differences-1" href="#Notable-Differences-1">Notable Differences</a></h2><ul><li><p>The julia workers don&#39;t execute computations in a thread pool but rather do so asynchronously. The recommended way to setup the workers is to use <code>addprocs</code> and spawn at least one <code>Worker</code> per julia process added in the cluster.</p></li><li><p>Currently the julia workers do not support specifying <code>resources</code> needed by computations or spilling excess data onto disk.</p></li></ul><h2><a class="nav-anchor" id="Tasks-1" href="#Tasks-1">Tasks</a></h2><p>Usually computations submitted to a worker go through task states in the following order:</p><pre><code class="language-none">waiting -&gt; ready -&gt; executing -&gt; memory</code></pre><p>Computations that result in errors being thrown are caught and the error is saved in memory. Workers communicate between themselves to gather dependencies and with the dask-scheduler.</p><h2><a class="nav-anchor" id="API-1" href="#API-1">API</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.Worker" href="#DaskDistributedDispatcher.Worker"><code>DaskDistributedDispatcher.Worker</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Worker</code></pre><p>A <code>Worker</code> represents a worker endpoint in the distributed cluster. It accepts instructions from the scheduler, fetches dependencies, executes compuations, stores data, and communicates state to the scheduler.</p><p><strong>Fields</strong></p><ul><li><p><code>status::Symbol</code>: status of this worker</p></li><li><p><code>address::Address</code>:: ip address and port that this worker is listening on</p></li><li><p><code>listener::Base.TCPServer</code>: tcp server that listens for incoming connections</p></li><li><p><code>scheduler_address::Address</code>: the dask-distributed scheduler ip address and port info</p></li><li><p><code>batched_stream::Nullable{BatchedSend}</code>: batched stream for communication with scheduler</p></li><li><p><code>scheduler::Rpc</code>: manager for discrete send/receive open connections to the scheduler</p></li><li><p><code>connection_pool::ConnectionPool</code>: manages connections to peers</p></li><li><p><code>handlers::Dict{String, Function}</code>: handlers for operations requested by open connections</p></li><li><p><code>compute_stream_handlers::Dict{String, Function}</code>: handlers for compute stream operations</p></li><li><p><code>transitions::Dict{Tuple, Function}</code>: valid transitions that a task can make</p></li><li><p><code>data_needed::Deque{String}</code>: keys whose data we still lack</p></li><li><p><code>ready::PriorityQueue{String, Tuple, Base.Order.ForwardOrdering}</code>: keys ready to run</p></li><li><p><code>data::Dict{String, Any}</code>: maps keys to the results of function calls (actual values)</p></li><li><p><code>tasks::Dict{String, Tuple}</code>: maps keys to the function, args, and kwargs of a task</p></li><li><p><code>task_state::Dict{String, Symbol}</code>: maps keys tot heir state: (waiting, executing, memory)</p></li><li><p><code>priorities::Dict{String, Tuple}</code>: run time order priority of a key given by the scheduler</p></li><li><p><code>priority_counter::Int</code>: used to prioritize tasks by their order of arrival</p></li><li><p><code>dep_transitions::Dict{Tuple, Function}</code>: valid transitions that a dependency can make</p></li><li><p><code>dep_state::Dict{String, Symbol}</code>: maps dependencies with their state   (waiting, flight, memory)</p></li><li><p><code>dependencies::Dict{String, Set}</code>: maps a key to the data it needs to run</p></li><li><p><code>dependents::Dict{String, Set}</code>: maps a dependency to the keys that use it</p></li><li><p><code>waiting_for_data::Dict{String, Set}</code>: maps a key to the data it needs that we don&#39;t have</p></li><li><p><code>pending_data_per_worker::DefaultDict{String, Deque}</code>: data per worker that we want</p></li><li><p><code>who_has::Dict{String, Set}</code>: maps keys to the workers believed to have their data</p></li><li><p><code>has_what::DefaultDict{String, Set{String}}</code>: maps workers to the data they have</p></li><li><p><code>in_flight_workers::Dict{String, Set}</code>: workers from which we are getting data from</p></li><li><p><code>missing_dep_flight::Set{String}</code>: missing dependencies</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L4-L45">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.Worker-Tuple{String}" href="#DaskDistributedDispatcher.Worker-Tuple{String}"><code>DaskDistributedDispatcher.Worker</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">Worker(scheduler_address::String=&quot;127.0.0.1:8786&quot;)</code></pre><p>Create a <code>Worker</code> that listens on a random port between 1024 and 9000 for incoming messages. By default if the scheduler&#39;s address is not provided it assumes that the dask-scheduler is being run on the same machine and on the default port 8786.</p><p><strong>NOTE</strong>: Worker&#39;s must be started in the same julia cluster as the <code>DaskExecutor</code> (and it&#39;s <code>Client</code>).</p><p><strong>Usage</strong></p><pre><code class="language-julia">Worker()  # The dask-scheduler is being run on the same machine on its default port 8786.</code></pre><p>or also</p><pre><code class="language-julia">Worker(&quot;$(getipaddr()):8786&quot;) # Scheduler is running on the same machine</code></pre><p>If running the dask-scheduler on a different machine or port:</p><ul><li><p>First start the <code>dask-scheduler</code> and inspect its startup logs:</p></li></ul><pre><code class="language-none">$ dask-scheduler
distributed.scheduler - INFO - -----------------------------------------------
distributed.scheduler - INFO -   Scheduler at:   tcp://127.0.0.1:8786
distributed.scheduler - INFO - etc.
distributed.scheduler - INFO - -----------------------------------------------</code></pre><ul><li><p>Then start workers with it&#39;s printed address:</p></li></ul><pre><code class="language-julia">Worker(&quot;tcp://127.0.0.1:8786&quot;)</code></pre><p>No further actions are needed directly on the Worker&#39;s themselves as they will communicate with the <code>dask-scheduler</code> independently. New <code>Worker</code>s can be added/removed at any time during execution. There usually should be at least one <code>Worker</code> to run computations.</p><p><strong>Cleanup</strong></p><p>To explicitly shutdown a worker and delete it&#39;s information use:</p><pre><code class="language-julia">worker = Worker()
shutdown([worker.address])</code></pre><p>It is more effective to explicitly reset the <a href="api.html#DaskDistributedDispatcher.DaskExecutor"><code>DaskExecutor</code></a> or shutdown a <a href="api.html#DaskDistributedDispatcher.Client"><code>Client</code></a> rather than a <code>Worker</code> because the dask-scheduler will automatically re-schedule the lost computations on other <code>Workers</code> if it thinks that a <a href="api.html#DaskDistributedDispatcher.Client"><code>Client</code></a> still needs the lost data.</p><p><code>Worker</code>&#39;s are lost if they were spawned on a julia process that exits or is removed via <code>rmprocs</code> from the julia cluster. It is cleaner but not necessary to explicity call <code>shutdown</code> if planning to remove a <code>Worker</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L87-L148">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.shutdown-Tuple{Array{DaskDistributedDispatcher.Address,1}}" href="#DaskDistributedDispatcher.shutdown-Tuple{Array{DaskDistributedDispatcher.Address,1}}"><code>DaskDistributedDispatcher.shutdown</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">shutdown(workers::Vector{Address})</code></pre><p>Connect to and terminate all workers in <code>workers</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L221-L225">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.show-Tuple{IO,DaskDistributedDispatcher.Worker}" href="#Base.show-Tuple{IO,DaskDistributedDispatcher.Worker}"><code>Base.show</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">show(io::IO, worker::Worker)</code></pre><p>Print a representation of the worker and it&#39;s state.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L245-L249">source</a><br/></section><h2><a class="nav-anchor" id="Internals-1" href="#Internals-1">Internals</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.start-Tuple{DaskDistributedDispatcher.Worker}" href="#DaskDistributedDispatcher.start-Tuple{DaskDistributedDispatcher.Worker}"><code>DaskDistributedDispatcher.start</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">start(worker::Worker)</code></pre><p>Coordinate a worker&#39;s startup.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L265-L269">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.register-Tuple{DaskDistributedDispatcher.Worker}" href="#DaskDistributedDispatcher.register-Tuple{DaskDistributedDispatcher.Worker}"><code>DaskDistributedDispatcher.register</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">register(worker::Worker)</code></pre><p>Register a <code>Worker</code> with the dask-scheduler process.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L283-L287">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.handle_comm-Tuple{DaskDistributedDispatcher.Worker,TCPSocket}" href="#DaskDistributedDispatcher.handle_comm-Tuple{DaskDistributedDispatcher.Worker,TCPSocket}"><code>DaskDistributedDispatcher.handle_comm</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">handle_comm(worker::Worker, comm::TCPSocket)</code></pre><p>Listen for incoming messages on an established connection.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L310-L314">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.close-Tuple{DaskDistributedDispatcher.Worker}" href="#Base.close-Tuple{DaskDistributedDispatcher.Worker}"><code>Base.close</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">Base.close(worker::Worker; report::String=&quot;true&quot;)</code></pre><p>Close the worker and all the connections it has open.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L402-L406">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.get_data-Tuple{DaskDistributedDispatcher.Worker}" href="#DaskDistributedDispatcher.get_data-Tuple{DaskDistributedDispatcher.Worker}"><code>DaskDistributedDispatcher.get_data</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">get_data(worker::Worker; keys::Array=String[], who::String=&quot;&quot;) -&gt; Dict</code></pre><p>Send the results of <code>keys</code> back over the stream they were requested on.</p><p><strong>Returns</strong></p><ul><li><p><code>Dict{String, Vector{UInt8}}</code>: dictionary mapping keys to their serialized data for   communication</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L435-L443">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.gather-Tuple{DaskDistributedDispatcher.Worker}" href="#DaskDistributedDispatcher.gather-Tuple{DaskDistributedDispatcher.Worker}"><code>DaskDistributedDispatcher.gather</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">gather(worker::Worker; who_has::Dict=Dict{String, Vector{String}}())</code></pre><p>Gather the results for various keys.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L453-L457">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.update_data-Tuple{DaskDistributedDispatcher.Worker}" href="#DaskDistributedDispatcher.update_data-Tuple{DaskDistributedDispatcher.Worker}"><code>DaskDistributedDispatcher.update_data</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">update_data(worker::Worker; data::Dict=Dict(), report::String=&quot;true&quot;) -&gt; Dict</code></pre><p>Update the worker data.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L481-L485">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.delete_data-Tuple{DaskDistributedDispatcher.Worker}" href="#DaskDistributedDispatcher.delete_data-Tuple{DaskDistributedDispatcher.Worker}"><code>DaskDistributedDispatcher.delete_data</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">delete_data(worker::Worker; keys::Array=String[], report::String=&quot;true&quot;)</code></pre><p>Delete the data associated with each key of <code>keys</code> in <code>worker.data</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L518-L522">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.terminate-Tuple{DaskDistributedDispatcher.Worker}" href="#DaskDistributedDispatcher.terminate-Tuple{DaskDistributedDispatcher.Worker}"><code>DaskDistributedDispatcher.terminate</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">terminate(worker::Worker; report::String=&quot;true&quot;)</code></pre><p>Shutdown the worker and close all its connections.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L538-L542">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.get_keys-Tuple{DaskDistributedDispatcher.Worker}" href="#DaskDistributedDispatcher.get_keys-Tuple{DaskDistributedDispatcher.Worker}"><code>DaskDistributedDispatcher.get_keys</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">get_keys(worker::Worker) -&gt; Vector{String}</code></pre><p>Get a list of all the keys held by this worker for communication with scheduler and other workers.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L548-L553">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.add_task-Tuple{DaskDistributedDispatcher.Worker}" href="#DaskDistributedDispatcher.add_task-Tuple{DaskDistributedDispatcher.Worker}"><code>DaskDistributedDispatcher.add_task</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">add_task(worker::Worker; kwargs...)</code></pre><p>Add a task to the worker&#39;s list of tasks to be computed.</p><p><strong>Keywords</strong></p><ul><li><p><code>key::String</code>: The tasks&#39;s unique identifier. Throws an exception if blank.</p></li><li><p><code>priority::Array</code>: The priority of the task. Throws an exception if blank.</p></li><li><p><code>who_has::Dict</code>: Map of dependent keys and the addresses of the workers that have them.</p></li><li><p><code>func::Union{String, Vector{UInt8}}</code>: The callable funtion for the task, serialized.</p></li><li><p><code>args::Union{String, Vector{UInt8}}}</code>: The arguments for the task, serialized.</p></li><li><p><code>kwargs::Union{String, Vector{UInt8}}</code>: The keyword arguments for the task, serialized.</p></li><li><p><code>future::Union{String, Vector{UInt8}}}</code>: The tasks&#39;s serialized <code>DeferredFuture</code>.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L558-L572">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.release_key-Tuple{DaskDistributedDispatcher.Worker}" href="#DaskDistributedDispatcher.release_key-Tuple{DaskDistributedDispatcher.Worker}"><code>DaskDistributedDispatcher.release_key</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">release_key(worker::Worker; key::String=&quot;&quot;, cause::String=&quot;&quot;, reason::String=&quot;&quot;)</code></pre><p>Delete a key and its data.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L671-L675">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.release_dep-Tuple{DaskDistributedDispatcher.Worker,String}" href="#DaskDistributedDispatcher.release_dep-Tuple{DaskDistributedDispatcher.Worker,String}"><code>DaskDistributedDispatcher.release_dep</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">release_dep(worker::Worker, dep::String)</code></pre><p>Delete a dependency key and its data.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L711-L715">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.ensure_computing-Tuple{DaskDistributedDispatcher.Worker}" href="#DaskDistributedDispatcher.ensure_computing-Tuple{DaskDistributedDispatcher.Worker}"><code>DaskDistributedDispatcher.ensure_computing</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">ensure_computing(worker::Worker)</code></pre><p>Make sure the worker is computing available tasks.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L738-L742">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.execute-Tuple{DaskDistributedDispatcher.Worker,String}" href="#DaskDistributedDispatcher.execute-Tuple{DaskDistributedDispatcher.Worker,String}"><code>DaskDistributedDispatcher.execute</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">execute(worker::Worker, key::String)</code></pre><p>Execute the task identified by <code>key</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L752-L756">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.put_key_in_memory-Tuple{DaskDistributedDispatcher.Worker,String,Any}" href="#DaskDistributedDispatcher.put_key_in_memory-Tuple{DaskDistributedDispatcher.Worker,String,Any}"><code>DaskDistributedDispatcher.put_key_in_memory</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">put_key_in_memory(worker::Worker, key::String, value; should_transition::Bool=true)</code></pre><p>Store the result (<code>value</code>) of the task identified by <code>key</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L792-L796">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.ensure_communicating-Tuple{DaskDistributedDispatcher.Worker}" href="#DaskDistributedDispatcher.ensure_communicating-Tuple{DaskDistributedDispatcher.Worker}"><code>DaskDistributedDispatcher.ensure_communicating</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">ensure_communicating(worker::Worker)</code></pre><p>Ensure the worker is communicating with its peers to gather dependencies as needed.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L821-L825">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.gather_dep-Tuple{DaskDistributedDispatcher.Worker,String,String,Set{String}}" href="#DaskDistributedDispatcher.gather_dep-Tuple{DaskDistributedDispatcher.Worker,String,String,Set{String}}"><code>DaskDistributedDispatcher.gather_dep</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">gather_dep(worker::Worker, worker_addr::String, dep::String, deps::Set; cause::String=&quot;&quot;)</code></pre><p>Gather the dependency with identifier &quot;dep&quot; from <code>worker_addr</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L900-L904">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.handle_missing_dep-Tuple{DaskDistributedDispatcher.Worker,Set{String}}" href="#DaskDistributedDispatcher.handle_missing_dep-Tuple{DaskDistributedDispatcher.Worker,Set{String}}"><code>DaskDistributedDispatcher.handle_missing_dep</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">handle_missing_dep(worker::Worker, deps::Set{String})</code></pre><p>Handle a missing dependency that can&#39;t be found on any peers.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L973-L977">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.update_who_has-Tuple{DaskDistributedDispatcher.Worker,Dict{String,Array{String,1}}}" href="#DaskDistributedDispatcher.update_who_has-Tuple{DaskDistributedDispatcher.Worker,Dict{String,Array{String,1}}}"><code>DaskDistributedDispatcher.update_who_has</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">update_who_has(worker::Worker, who_has::Dict{String, Vector{String}})</code></pre><p>Ensure <code>who_has</code> is up to date and accurate.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L1018-L1022">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.select_keys_for_gather-Tuple{DaskDistributedDispatcher.Worker,String,String}" href="#DaskDistributedDispatcher.select_keys_for_gather-Tuple{DaskDistributedDispatcher.Worker,String,String}"><code>DaskDistributedDispatcher.select_keys_for_gather</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">select_keys_for_gather(worker::Worker, worker_addr::String, dep::String)</code></pre><p>Select which keys to gather from peer at <code>worker_addr</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L1039-L1043">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.gather_from_workers-Tuple{Dict{String,Array{String,1}},DaskDistributedDispatcher.ConnectionPool}" href="#DaskDistributedDispatcher.gather_from_workers-Tuple{Dict{String,Array{String,1}},DaskDistributedDispatcher.ConnectionPool}"><code>DaskDistributedDispatcher.gather_from_workers</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">gather_from_workers(who_has::Dict, connection_pool::ConnectionPool) -&gt; Tuple</code></pre><p>Gather data directly from <code>who_has</code> peers.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L1059-L1063">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.transition-Tuple{DaskDistributedDispatcher.Worker,String,Symbol}" href="#DaskDistributedDispatcher.transition-Tuple{DaskDistributedDispatcher.Worker,String,Symbol}"><code>DaskDistributedDispatcher.transition</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">transition(worker::Worker, key::String, finish_state::Symbol; kwargs...)</code></pre><p>Transition task with identifier <code>key</code> to finish_state from its current state.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L1142-L1146">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.transition_dep-Tuple{DaskDistributedDispatcher.Worker,String,Symbol}" href="#DaskDistributedDispatcher.transition_dep-Tuple{DaskDistributedDispatcher.Worker,String,Symbol}"><code>DaskDistributedDispatcher.transition_dep</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">transition_dep(worker::Worker, dep::String, finish_state::Symbol; kwargs...)</code></pre><p>Transition dependency task with identifier <code>key</code> to finish_state from its current state.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L1191-L1195">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.send_task_state_to_scheduler-Tuple{DaskDistributedDispatcher.Worker,String}" href="#DaskDistributedDispatcher.send_task_state_to_scheduler-Tuple{DaskDistributedDispatcher.Worker,String}"><code>DaskDistributedDispatcher.send_task_state_to_scheduler</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">send_task_state_to_scheduler(worker::Worker, key::String)</code></pre><p>Send the state of task <code>key</code> to the scheduler.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L1248-L1252">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.deserialize_task-Tuple{Array{UInt8,1},Array{UInt8,1},Array{UInt8,1},Array{UInt8,1}}" href="#DaskDistributedDispatcher.deserialize_task-Tuple{Array{UInt8,1},Array{UInt8,1},Array{UInt8,1},Array{UInt8,1}}"><code>DaskDistributedDispatcher.deserialize_task</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">deserialize_task(func, args, kwargs, future) -&gt; Tuple</code></pre><p>Deserialize task inputs and regularize to func, args, kwargs.</p><p><strong>Returns</strong></p><ul><li><p><code>Tuple</code>: The deserialized function, arguments, keyword arguments, and Deferredfuture for</p></li></ul><p>the task.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L1269-L1277">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.apply_function-Tuple{String,Union{DataType,Function},Tuple,Array{Any,1}}" href="#DaskDistributedDispatcher.apply_function-Tuple{String,Union{DataType,Function},Tuple,Array{Any,1}}"><code>DaskDistributedDispatcher.apply_function</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">apply_function(key::String, func::Base.Callable, args::Any, kwargs::Any)</code></pre><p>Run a function and return collected information.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/133f967f00ab8e9512939e2e8a70afb58693f894/src/worker.jl#L1293-L1297">source</a><br/></section><footer><hr/><a class="previous" href="api.html"><span class="direction">Previous</span><span class="title">API</span></a><a class="next" href="communication.html"><span class="direction">Next</span><span class="title">Communication</span></a></footer></article></body></html>

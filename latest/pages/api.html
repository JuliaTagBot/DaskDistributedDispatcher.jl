<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · DaskDistributedDispatcher.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/invenia.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DaskDistributedDispatcher.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><a class="toctext" href="manual.html">Manual</a></li><li class="current"><a class="toctext" href="api.html">API</a><ul class="internal"><li><a class="toctext" href="#DaskExecutor-1">DaskExecutor</a></li><li><a class="toctext" href="#Client-1">Client</a></li><li><a class="toctext" href="#Address-1">Address</a></li></ul></li><li><a class="toctext" href="workers.html">Workers</a></li><li><a class="toctext" href="communication.html">Communication</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="api.html">API</a></li></ul><a class="edit-page" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/docs/src/pages/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-1" href="#API-1">API</a></h1><h2><a class="nav-anchor" id="DaskExecutor-1" href="#DaskExecutor-1">DaskExecutor</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.DaskExecutor" href="#DaskDistributedDispatcher.DaskExecutor"><code>DaskDistributedDispatcher.DaskExecutor</code></a> — <span class="docstring-category">Type</span>.</div><div><p><code>DaskExecutor</code> is an <a href="https://invenia.github.io/Dispatcher.jl/latest/pages/api.html#Dispatcher.Executor"><code>Executor</code></a>  which executes julia computations as scheduled by the python <a href="https://distributed.readthedocs.io/en/latest/scheduling-policies.html"><code>dask-scheduler</code></a>. It can run computations both asynchronously or in parallel (if <a href="workers.html#DaskDistributedDispatcher.Worker"><code>Worker</code></a>s are started on a julia cluster instead).</p><p><code>DaskExecutor</code>&#39;s <a href="api.html#DaskDistributedDispatcher.dispatch!-Tuple{DaskDistributedDispatcher.DaskExecutor,Dispatcher.DispatchNode}"><code>dispatch!(::DaskExecutor, ::Dispatcher.DispatchNode)</code></a> method will complete as long as there are no cycles in the computation graph, the <a href="https://distributed.readthedocs.io/en/latest/scheduling-policies.html"><code>dask-scheduler</code></a> remains online, and there is at least one <a href="workers.html#DaskDistributedDispatcher.Worker"><code>Worker</code></a> that is listening to the <a href="https://distributed.readthedocs.io/en/latest/scheduling-policies.html"><code>dask-scheduler</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/executor.jl#L10-L23">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.DaskExecutor-Tuple{String}" href="#DaskDistributedDispatcher.DaskExecutor-Tuple{String}"><code>DaskDistributedDispatcher.DaskExecutor</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">DaskExecutor(scheduler_address::String=&quot;$(getipaddr()):8786&quot;)</code></pre><p>Return a new <a href="api.html#DaskDistributedDispatcher.DaskExecutor"><code>DaskExecutor</code></a>. The <code>scheduler_address</code> only needs to be included if the <a href="https://distributed.readthedocs.io/en/latest/setup.html"><code>dask-scheduler</code></a>  is running on a different machine or not on it&#39;s default port (8786).</p><p><strong>NOTE</strong>: A <a href="https://distributed.readthedocs.io/en/latest/setup.html"><code>dask-scheduler</code></a> must be running at all times or the <a href="api.html#DaskDistributedDispatcher.DaskExecutor"><code>DaskExecutor</code></a> execution will fail. If the scheduler is taken offline during execution for some reason, any remaining operations will fail to complete. Start a <a href="https://distributed.readthedocs.io/en/latest/setup.html"><code>dask-scheduler</code></a> from a terminal by typing <code>dask-scheduler</code>:</p><pre><code class="language-none">$ dask-scheduler
Start scheduler at 192.168.0.1:8786</code></pre><p><strong>Prerequisites</strong></p><ul><li><p>python 2.7 or 3.5</p></li><li><p>the python dask.distributed package (<a href="http://distributed.readthedocs.io/en/latest/install.html"><code>instructions for install here</code></a>)</p></li></ul><p>Note that using the <code>dask-scheduler</code> and executing compuations in a distributed manner can <a href="https://distributed.readthedocs.io/en/latest/efficiency.html"><code>add overhead for simple tasks</code></a>. Consider using an <a href="https://invenia.github.io/Dispatcher.jl/latest/pages/api.html#AsyncExecutor-1"><code>AsyncExecuter</code></a> or <a href="https://invenia.github.io/Dispatcher.jl/latest/pages/api.html#ParallelExecutor-1"><code>ParallelExecuter</code></a> if possible. The advantage that using the <code>dask-scheduler</code> has is that it schedules computations in a manner that is <a href="https://distributed.readthedocs.io/en/latest/scheduling-policies.html"><code>short-term-efficient and long-term-fair</code></a>.</p><p><strong>Usage</strong></p><p>The <a href="api.html#DaskDistributedDispatcher.DaskExecutor"><code>DaskExecutor</code></a> can run both asynchronously with the <a href="workers.html#DaskDistributedDispatcher.Worker"><code>Worker</code></a>s, or in parallel if <a href="workers.html#DaskDistributedDispatcher.Worker"><code>Worker</code></a>s are spawned on separate julia processes in a cluster.</p><p><strong>NOTE</strong>: Users must startup at least one <a href="workers.html#DaskDistributedDispatcher.Worker"><code>Worker</code></a> by pointing it to the <code>dask-scheduler</code>&#39;s address or else <a href="https://invenia.github.io/Dispatcher.jl/latest/pages/api.html#Dispatcher.run!-Tuple{Dispatcher.Executor,Dispatcher.DispatchContext,AbstractArray{T&lt;:Dispatcher.DispatchNode,N},AbstractArray{S&lt;:Dispatcher.DispatchNode,N}} "><code>run!</code></a> will hang indefinetely.</p><p><strong>Examples</strong></p><ul><li><p>Running asynchronously:</p></li></ul><pre><code class="language-julia"># Reminder: make sure the dask-scheduler is running
using DaskDistributedDispatcher
using Dispatcher
using ResultTypes

Worker()

exec = DaskExecutor()
ctx = DispatchContext()
n1 = add!(ctx, Op(()-&gt;3))
n2 = add!(ctx, Op(()-&gt;4))

results = run!(exec, ctx)

fetch(unwrap(results[1]))  # 3
fetch(unwrap(results[2]))  # 4</code></pre><ul><li><p>Running in parallel:</p></li></ul><pre><code class="language-julia"># Reminder: make sure the dask-scheduler is running
using DaskDistributedDispatcher
using Dispatcher
using ResultTypes

addprocs(3)
@everywhere using DaskDistributedDispatcher

for i in 1:3
    cond = @spawn Worker()
    wait(cond)
end

exec = DaskExecutor()
ctx = DispatchContext()
n1 = add!(ctx, Op(()-&gt;3))
n2 = add!(ctx, Op(()-&gt;4))

results = run!(exec, ctx)

fetch(unwrap(results[1]))  # 3
fetch(unwrap(results[2]))  # 4</code></pre><p>To delete all previously computed information from the workers:</p><pre><code class="language-julia">reset(exec)</code></pre><p><strong>Advanced Workflows</strong></p><p>It is possible to bypass the <a href="api.html#DaskDistributedDispatcher.DaskExecutor"><code>DaskExecutor</code></a> and use the <a href="api.html#DaskDistributedDispatcher.Client"><code>Client</code></a> directly to submit compuations, cancel previously scheduled <a href="https://invenia.github.io/Dispatcher.jl/latest/pages/api.html#DispatchNode-1"><code>DispatchNode</code></a>s, gather results, or replicate data across all workers. See <a href="api.html#DaskDistributedDispatcher.Client"><code>Client</code></a> for more details. It is recommened to start with a <a href="api.html#DaskDistributedDispatcher.DaskExecutor"><code>DaskExecutor</code></a> and access its <code>client</code> field if needed later on.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/executor.jl#L31-L142">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.dispatch!-Tuple{DaskDistributedDispatcher.DaskExecutor,Dispatcher.DispatchContext}" href="#Dispatcher.dispatch!-Tuple{DaskDistributedDispatcher.DaskExecutor,Dispatcher.DispatchContext}"><code>Dispatcher.dispatch!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dispatch!(exec::DaskExecutor, ctx::DispatchContext; throw_error=true) -&gt; Vector</code></pre><p>The default <code>dispatch!</code> method uses <code>asyncmap</code> over all nodes in the context to call <code>dispatch!(exec, node)</code>. These <code>dispatch!</code> calls for each node are wrapped in various retry and error handling methods.</p><p><strong>Wrapping Details</strong></p><ol><li><p>All nodes are wrapped in a try catch which waits on the value returned from the <code>dispatch!(exec, node)</code> call. Any errors are caught and used to create <a href="https://invenia.github.io/Dispatcher.jl/latest/pages/api.html#Dispatcher.DependencyError"><code>DependencyError</code></a>s which are thrown. If no errors are produced then the node is returned.</p><p><strong>NOTE</strong>: All errors thrown by trying to run <code>dispatch!(exec, node)</code> are wrapped in a <code>DependencyError</code>.</p></li><li><p>By default the <a href="api.html#DaskDistributedDispatcher.DaskExecutor"><code>DaskExecutor</code></a> has no <a href="api.html#DaskDistributedDispatcher.retry_on-Tuple{DaskDistributedDispatcher.DaskExecutor}"><code>retry_on</code></a> functions since retrying failed <code>ops</code> is not explicitly supported by the dask-scheduler.</p></li><li><p>A node may enter a failed state if it exits the retry wrapper with an exception. In the situation where a node has entered a failed state and the node is an <code>Op</code> then the <code>op.result</code> is set to the <code>DependencyError</code>, signifying the node&#39;s failure to any dependent nodes. Finally, if <code>throw_error</code> is true then the <code>DependencyError</code> will be immediately thrown in the current process without allowing other nodes to finish. If <code>throw_error</code> is false then the <code>DependencyError</code> is not thrown and it will be returned in the array of passing and failing nodes.</p></li></ol><p><strong>Arguments</strong></p><ul><li><p><code>exec::DaskExecutor</code>: the executor we&#39;re running</p></li><li><p><code>ctx::DispatchContext</code>: the context of nodes to run</p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>throw_error::Bool=true</code>: whether or not to throw the <code>DependencyError</code> for failed nodes</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>Vector{Union{DispatchNode, DependencyError}}</code>: a list of <code>DispatchNode</code>s or <code>DependencyError</code>s for failed nodes</p></li></ul><p><strong>Throws</strong></p><ul><li><p><code>dispatch!</code> has the same behaviour on exceptions as <code>asyncmap</code> and <code>pmap</code>. In 0.5 this will throw a <code>CompositeException</code> containing <code>DependencyError</code>s, while in 0.6 this will simply throw the first <code>DependencyError</code>.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/executor.jl#L150-L198">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.reset!-Tuple{DaskDistributedDispatcher.DaskExecutor}" href="#DaskDistributedDispatcher.reset!-Tuple{DaskDistributedDispatcher.DaskExecutor}"><code>DaskDistributedDispatcher.reset!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">reset!(exec::DaskExecutor)</code></pre><p>Restarts the executor&#39;s <a href="api.html#DaskDistributedDispatcher.Client"><code>Client</code></a>, which tells the scheduler to delete previously computed data since it is not needed anymore. The scheduler, in turn, signals this to the workers.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/executor.jl#L302-L308">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.retries-Tuple{DaskDistributedDispatcher.DaskExecutor}" href="#DaskDistributedDispatcher.retries-Tuple{DaskDistributedDispatcher.DaskExecutor}"><code>DaskDistributedDispatcher.retries</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">retries(exec::DaskExecutor) -&gt; Int</code></pre><p>Return the number of retries per node.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/executor.jl#L314-L318">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.retry_on-Tuple{DaskDistributedDispatcher.DaskExecutor}" href="#DaskDistributedDispatcher.retry_on-Tuple{DaskDistributedDispatcher.DaskExecutor}"><code>DaskDistributedDispatcher.retry_on</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">retry_on(exec::DaskExecutor) -&gt; Vector{Function}</code></pre><p>Return the array of retry conditions.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/executor.jl#L321-L325">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.dispatch!-Tuple{DaskDistributedDispatcher.DaskExecutor,Dispatcher.DispatchNode}" href="#DaskDistributedDispatcher.dispatch!-Tuple{DaskDistributedDispatcher.DaskExecutor,Dispatcher.DispatchNode}"><code>DaskDistributedDispatcher.dispatch!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dispatch!(exec::DaskExecutor, node::Dispatcher.DispatchNode) -&gt; Future</code></pre><p><code>dispatch!</code> takes the <code>DaskExecutor</code> and a <a href="https://invenia.github.io/Dispatcher.jl/latest/pages/api.html#Dispatcher.DispatchNode"><code>DispatchNode</code></a> to run and submits the <a href="https://invenia.github.io/Dispatcher.jl/latest/pages/api.html#Dispatcher.DispatchNode"><code>DispatchNode</code></a> to the <a href="api.html#DaskDistributedDispatcher.Client"><code>Client</code></a> for scheduling.</p><p>This is the defining method of <code>DaskExecutor</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/executor.jl#L328-L338">source</a><br/></section><h2><a class="nav-anchor" id="Client-1" href="#Client-1">Client</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.Client" href="#DaskDistributedDispatcher.Client"><code>DaskDistributedDispatcher.Client</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Client</code></pre><p>Client that can be interacted with to submit computations to the scheduler and gather results. Should only be used directly for advanced workflows. See <a href="api.html#DaskDistributedDispatcher.DaskExecutor"><code>DaskExecutor</code></a> instead for normal usage.</p><p><strong>Fields</strong></p><ul><li><p><code>nodes::Dict{String, DispatchNode}</code>: maps keys to their dispatcher <code>DispatchNode</code></p></li><li><p><code>id::String</code>: this client&#39;s identifier</p></li><li><p><code>status::String</code>: status of this client</p></li><li><p><code>scheduler_address::Address</code>: the dask-distributed scheduler ip address and port info</p></li><li><p><code>scheduler::Rpc</code>: manager for discrete send/receive open connections to the scheduler</p></li><li><p><code>connecting_to_scheduler::Bool</code>: if client is currently trying to connect to the scheduler</p></li><li><p><code>scheduler_comm::Nullable{BatchedSend}</code>: batched stream for communication with scheduler</p></li><li><p><code>pending_msg_buffer::Array</code>: pending msgs to send on the batched stream</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/client.jl#L4-L20">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.Client-Tuple{String}" href="#DaskDistributedDispatcher.Client-Tuple{String}"><code>DaskDistributedDispatcher.Client</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">Client(scheduler_address::String) -&gt; Client</code></pre><p>Construct a <code>Client</code> which can then be used to submit computations or gather results from the dask-scheduler process.</p><p><strong>Usage</strong></p><pre><code class="language-julia">using DaskDistributedDispatcher
using Dispatcher

addprocs(3)
@everywhere using DaskDistributedDispatcher

for i in 1:3
    @spawn Worker(&quot;127.0.0.1:8786&quot;)
end

client = Client(&quot;127.0.0.1:8786&quot;)

op = Op(Int, 2.0)
submit(client, op)
result = fetch(op)</code></pre><p>Previously submitted <code>Ops</code> can be cancelled by calling:</p><pre><code class="language-julia">cancel(client, [op])

# Or if using the `DaskExecutor`
cancel(executor.client, [op])</code></pre><p>If needed, which worker(s) to run the computations on can be explicitly specified by returning the worker&#39;s address when starting a new worker:</p><pre><code class="language-julia">using DaskDistributedDispatcher
client = Client(&quot;127.0.0.1:8786&quot;)

pnums = addprocs(1)
@everywhere using DaskDistributedDispatcher

worker_address = @fetchfrom pnums[1] begin
    worker = Worker(&quot;127.0.0.1:8786&quot;)
    return worker.address
end

op = Op(Int, 1.0)
submit(client, op, workers=[worker_address])
result = result(client, op)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/client.jl#L32-L87">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.submit-Tuple{DaskDistributedDispatcher.Client,Dispatcher.DispatchNode}" href="#DaskDistributedDispatcher.submit-Tuple{DaskDistributedDispatcher.Client,Dispatcher.DispatchNode}"><code>DaskDistributedDispatcher.submit</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">submit(client::Client, node::DispatchNode; workers::Array{Address,1}=Array{Address,1}())</code></pre><p>Submit the <code>node</code> computation unit to the dask-scheduler for computation. Also submits all <code>node</code>&#39;s dependencies to the scheduler if they have not previously been submitted.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/client.jl#L153-L158">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.cancel-Tuple{DaskDistributedDispatcher.Client,Array{T&lt;:Dispatcher.DispatchNode,1}}" href="#DaskDistributedDispatcher.cancel-Tuple{DaskDistributedDispatcher.Client,Array{T&lt;:Dispatcher.DispatchNode,1}}"><code>DaskDistributedDispatcher.cancel</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">cancel{T&lt;:DispatchNode}(client::Client, nodes::Array{T, 1})</code></pre><p>Cancel all <code>DispatchNode</code>s in <code>nodes</code>. This stops future tasks from being scheduled if they have not yet run and deletes them if they have already run. After calling, this result and all dependent results will no longer be accessible.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/client.jl#L198-L204">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.gather-Tuple{DaskDistributedDispatcher.Client,Array{T&lt;:Dispatcher.DispatchNode,1}}" href="#DaskDistributedDispatcher.gather-Tuple{DaskDistributedDispatcher.Client,Array{T&lt;:Dispatcher.DispatchNode,1}}"><code>DaskDistributedDispatcher.gather</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">gather{T&lt;:DispatchNode}(client::Client, nodes::Array{T, 1})</code></pre><p>Gather the results of all <code>nodes</code>. Requires there to be at least one worker available to the scheduler or hangs indefinetely waiting for the results.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/client.jl#L219-L224">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.replicate-Tuple{DaskDistributedDispatcher.Client}" href="#DaskDistributedDispatcher.replicate-Tuple{DaskDistributedDispatcher.Client}"><code>DaskDistributedDispatcher.replicate</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">replicate{T&lt;:DispatchNode}(client::Client; nodes::Array{T, 1}=DispatchNode[])</code></pre><p>Copy data onto many workers. Helps to broadcast frequently accessed data and improve resilience.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/client.jl#L239-L244">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.shutdown-Tuple{DaskDistributedDispatcher.Client}" href="#DaskDistributedDispatcher.shutdown-Tuple{DaskDistributedDispatcher.Client}"><code>DaskDistributedDispatcher.shutdown</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">shutdown(client::Client)</code></pre><p>Tell the dask-scheduler that this client is shutting down. Does NOT terminate the scheduler itself nor the workers. This does not have to be called after a session but is useful to delete all the information submitted by the client from the scheduler and workers (such as between test runs). To reconnect to the scheduler after calling this function set up a new client.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/client.jl#L257-L265">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.get_key-Tuple{T&lt;:Dispatcher.DispatchNode}" href="#DaskDistributedDispatcher.get_key-Tuple{T&lt;:Dispatcher.DispatchNode}"><code>DaskDistributedDispatcher.get_key</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">get_key{T&lt;:DispatchNode}(node::T)</code></pre><p>Calculate an identifying key for <code>node</code>. Keys are re-used for identical <code>nodes</code> to avoid unnecessary computations.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/client.jl#L277-L282">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.ensure_connected-Tuple{DaskDistributedDispatcher.Client}" href="#DaskDistributedDispatcher.ensure_connected-Tuple{DaskDistributedDispatcher.Client}"><code>DaskDistributedDispatcher.ensure_connected</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">ensure_connected(client::Client)</code></pre><p>Ensure the <code>client</code> is connected to the dask-scheduler. For internal use.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/client.jl#L105-L109">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.send_to_scheduler-Tuple{DaskDistributedDispatcher.Client,Dict{String,Union{Array,Dict,String}}}" href="#DaskDistributedDispatcher.send_to_scheduler-Tuple{DaskDistributedDispatcher.Client,Dict{String,Union{Array,Dict,String}}}"><code>DaskDistributedDispatcher.send_to_scheduler</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">send_to_scheduler(client::Client, msg::Dict{String, Message})</code></pre><p>Send <code>msg</code> to the dask-scheduler that the client is connected to. For internal use.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/client.jl#L138-L142">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.serialize_deps-Tuple{DaskDistributedDispatcher.Client,Array{T&lt;:Dispatcher.DispatchNode,1},Array{Array{UInt8,1},N},Dict{Array{UInt8,1},Dict{String,Array{UInt8,1}}},Dict{Array{UInt8,1},Array{Array{UInt8,1},N}}}" href="#DaskDistributedDispatcher.serialize_deps-Tuple{DaskDistributedDispatcher.Client,Array{T&lt;:Dispatcher.DispatchNode,1},Array{Array{UInt8,1},N},Dict{Array{UInt8,1},Dict{String,Array{UInt8,1}}},Dict{Array{UInt8,1},Array{Array{UInt8,1},N}}}"><code>DaskDistributedDispatcher.serialize_deps</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">serialize_deps(client::Client, deps::Array, tkeys::Array, tasks::Dict, tasks_deps::Dict)</code></pre><p>Serialize all dependencies in <code>deps</code> to send to the scheduler. For internal use.</p><p><strong>Returns</strong></p><ul><li><p><code>tkeys::Array</code>: the keys that will be sent to the scheduler in byte form</p></li><li><p><code>tasks::Dict</code>: the serialized tasks that will be sent to the scheduler</p></li><li><p><code>tasks_deps::Dict</code>: the keys of the dependencies for each task</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/client.jl#L305-L314">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.serialize_node-Tuple{DaskDistributedDispatcher.Client,Dispatcher.DispatchNode}" href="#DaskDistributedDispatcher.serialize_node-Tuple{DaskDistributedDispatcher.Client,Dispatcher.DispatchNode}"><code>DaskDistributedDispatcher.serialize_node</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">serialize_node(client::Client, node::DispatchNode)</code></pre><p>Serialize all dependencies in <code>deps</code> to send to the scheduler. For internal use.</p><p><strong>Returns a tuple of:</strong></p><ul><li><p><code>task::Dict</code>: serialized task that will be sent to the scheduler</p></li><li><p><code>unprocessed_deps::Array</code>: list of dependencies that haven&#39;t been serialized yet</p></li><li><p><code>task_dependencies::Array</code>: the keys of the dependencies for <code>task</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/client.jl#L341-L350">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.serialize_task-Tuple{DaskDistributedDispatcher.Client,T&lt;:Dispatcher.DispatchNode,Array{T&lt;:Dispatcher.DispatchNode,1}}" href="#DaskDistributedDispatcher.serialize_task-Tuple{DaskDistributedDispatcher.Client,T&lt;:Dispatcher.DispatchNode,Array{T&lt;:Dispatcher.DispatchNode,1}}"><code>DaskDistributedDispatcher.serialize_task</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">serialize_task{T&lt;:DispatchNode}(client::Client, node::T, deps::Array) -&gt; Dict</code></pre><p>Serialize <code>node</code> into its components. For internal use.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/client.jl#L364-L368">source</a><br/></section><h2><a class="nav-anchor" id="Address-1" href="#Address-1">Address</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.Address" href="#DaskDistributedDispatcher.Address"><code>DaskDistributedDispatcher.Address</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Address</code></pre><p>A representation of an endpoint that can be connected to. It is categorized by its scheme (tcp is currently the only protocol supported), host, and port.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/address.jl#L1-L6">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.Address-Tuple{String}" href="#DaskDistributedDispatcher.Address-Tuple{String}"><code>DaskDistributedDispatcher.Address</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">Address(address::String) -&gt; Address</code></pre><p>Parse <code>address</code> and returns the corresponding <code>Address</code> object.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/address.jl#L13-L17">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.Address-Tuple{IPAddr,Integer}" href="#DaskDistributedDispatcher.Address-Tuple{IPAddr,Integer}"><code>DaskDistributedDispatcher.Address</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">Address(host::IPAddr, port::Integer)) -&gt; Address</code></pre><p>Return the corresponding <code>Address</code> object to the components <code>host</code> and <code>port</code>. By default the tcp protocol is assumed.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/address.jl#L22-L27">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.show-Tuple{IO,DaskDistributedDispatcher.Address}" href="#Base.show-Tuple{IO,DaskDistributedDispatcher.Address}"><code>Base.show</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">show(io::IO, address::Address)</code></pre><p>Print a representation of the address to <code>io</code>. The format used to represent addresses is &quot;tcp://127.0.0.1:port&quot;.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/address.jl#L38-L43">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.connect-Tuple{DaskDistributedDispatcher.Address}" href="#Base.connect-Tuple{DaskDistributedDispatcher.Address}"><code>Base.connect</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">Base.connect(address::Address)</code></pre><p>Open a tcp connection to <code>address</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/address.jl#L48-L52">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack.pack-Tuple{Base.AbstractIOBuffer{Array{UInt8,1}},DaskDistributedDispatcher.Address}" href="#MsgPack.pack-Tuple{Base.AbstractIOBuffer{Array{UInt8,1}},DaskDistributedDispatcher.Address}"><code>MsgPack.pack</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">MsgPack.pack(io::Base.AbstractIOBuffer{Array{UInt8,1}}, address::Address)</code></pre><p>Pack <code>address</code> as its string representation.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/address.jl#L55-L59">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DaskDistributedDispatcher.parse_address-Tuple{String}" href="#DaskDistributedDispatcher.parse_address-Tuple{String}"><code>DaskDistributedDispatcher.parse_address</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">parse_address(address::String) -&gt; (String, IpAddr, Integer)</code></pre><p>Parse an address into its scheme, host, and port components.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/DaskDistributedDispatcher.jl/tree/4fc9d836ef86b71a9265a22d3941f5626fcf0d14/src/address.jl#L64-L68">source</a><br/></section><footer><hr/><a class="previous" href="manual.html"><span class="direction">Previous</span><span class="title">Manual</span></a><a class="next" href="workers.html"><span class="direction">Next</span><span class="title">Workers</span></a></footer></article></body></html>
